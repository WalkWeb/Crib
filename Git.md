
# Полезные команды по Git

Не отслеживать изменение права файлов в git:

`git config core.filemode false`

Применить изменения конкретной версии из стеша:

```
$ git stash list
stash@{0}: ...
stash@{1}: ...
$ git stash apply stash@{0}
```

Если какие-то файлы были добавлено в git, а затем добавлены в .gitignore, то git продолжит показывать изменения в них.
Чтобы полностью убрать их из видимости гита:

Для файлов:

`git rm --cached file_name` 

Для директорий:

`git rm --cached -r dir_name` 

# Как совместить несколько коммитов в один (не через rebase)

Бывает так, что написав нужный функционал и создав коммит, потом приходит идея что-то улучшить, и добавляешь коммит
об улучшении, а потом еще на ревью делают замечания, и нужно их добавить. При этом хочется чтобы в истории гита все было
чисто - одна задача под функционал и один коммит.

При этом сделать это не средствами rebase, который мне видится сложным для понимания и использования.

Рассмотрим вариант с тремя коммитами:

```
Added notifications
Small improvements
Edits after review
```

Нужно просто три раза сделать:

`git reset HEAD~`

После чего создать новый коммит (можно с другим именем):

`Added notifications`

А затем, если предыдущие 3 коммита были уже запушены, делаем:

`git push origin branch_name -f`

Важно: менять историю коммитов можно только в тех ветках, которые никто кроме вас не использует. Соответственно делать
так в ветках master, main, dev и прочих - нельзя. Но правильная организация работы подразумевает, что на каждую отдельную
задачу создается отдельная ветка - то проблем никаких нет - вы измените историю коммитов только в своей ветке.

А вот если она уже была слита с основными ветками, то уже ничего безболезненно не поправить.

# Стандартный work-flow командной работы:

Начало работы - любая задача делается в отдельной ветке, ветка называется аналогично названию в YouTrack, Jira и т.д.:

`git checkout -b task-25`

После того, как код написан, создаем коммит и пушим ветку:

`it add . && git commit -m 'Added news'`

`git push origin task-25`

Далее в GitLab запускается пайплайн на проверки тестов, стиля кода и прочего, после этого делается ревью кода командой,
после чего через GitLab ветка мержится с dev/main-веткой.
